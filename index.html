<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Tigger</title>
  
    <link rel="icon" href="/assets/logo.png">
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/assets/header.png)">
        <div class='av-pic' style="background-image: url(/assets/logo.png)">
        </div>
    </section>
    <section class='menu'>
        <div>Tigger</div>
        
            <div>原力探索</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>首页</li>
            </a>
          
            <a href="/archives/" class="Btn">
              <li>归档</li>
            </a>
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>
          
            <a href="/categories/" class="Btn">
              <li>Categories</li>
            </a>
          
        </ul>
    </section>
    <section class="media">
        
            
                <a href="https://github.com/wanbei" target="_blank" rel="noopener">
                    <img src="/assets/github.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/12/15/react-redux/">React Redux 1.0.0</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-12-15T01:49:15.829Z" itemprop="datePublished">
    2020-12-15
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/React-Redux/">React Redux</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/Redux/">Redux</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/React-js/">React.js</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <a style="border-bottom: 0" href="https://pic4.zhimg.com/v2-b0f037c953c4aff17a871d0e6cb4079a_r.jpg" target="_blank">
<img src="https://pic4.zhimg.com/v2-b0f037c953c4aff17a871d0e6cb4079a_r.jpg" alt="Nest.js-脑图">
</a>


      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/12/04/Sequelize-ORM/">Sequelize ORM</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-12-04T05:20:45.426Z" itemprop="datePublished">
    2020-12-04
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Node-js/">Node.js</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/Nest-js/">Nest.js</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/Node-js/">Node.js</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <a style="border-bottom: 0" href="https://pic1.zhimg.com/v2-fc84411deb512170785d0e3b88fcaa6f_r.jpg" target="_blank">
<img src="https://pic3.zhimg.com/v2-daac1ed406d9a8ce424f5ce16d189db6_r.jpg" alt="Sequelize ORM">
</a>



      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/12/04/Nest.js/">Nest.js-学习脑图</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-12-04T02:52:54.601Z" itemprop="datePublished">
    2020-12-04
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Node-js/">Node.js</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/Nest-js/">Nest.js</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/Node-js/">Node.js</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <a style="border-bottom: 0" href="https://pic1.zhimg.com/v2-ac13978c1663728f06e4e759d38473ec_r.jpg" target="_blank">
<img src="https://pic1.zhimg.com/v2-ac13978c1663728f06e4e759d38473ec_r.jpg" alt="Nest.js-脑图">
</a>


      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/12/04/Message/">Message-组件脑图</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-12-04T02:45:17.096Z" itemprop="datePublished">
    2020-12-04
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/React/">React</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E7%BB%84%E4%BB%B6/">组件</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <a style="border-bottom: 0" href="https://pic1.zhimg.com/v2-fc84411deb512170785d0e3b88fcaa6f_r.jpg" target="_blank">
<img src="https://pic1.zhimg.com/v2-fc84411deb512170785d0e3b88fcaa6f_r.jpg" alt="Message-组件脑图">
</a>


      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/05/28/%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6/">醍醐灌顶</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-05-28T02:09:19.227Z" itemprop="datePublished">
    2020-05-28
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6/">醍醐灌顶</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6/">醍醐灌顶</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p><a href="https://agda-zh.github.io/PLFA-zh/" target="_blank" rel="noopener">编程语言基础：Agda 语言描述</a><br><a href="https://www.seas.upenn.edu/~sweirich/ssgip/" target="_blank" rel="noopener">Generic programming with Dependent Types</a></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/05/27/%E5%A6%82%E4%BD%95%E7%94%A8TypeScript%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/">如何用TypeScript实现一个泛型算法</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-05-27T14:56:35.499Z" itemprop="datePublished">
    2020-05-27
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E6%B3%9B%E5%9E%8B/">泛型</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p><img src="https://s1.ax1x.com/2020/05/28/tV7YrV.png" alt="tV7YrV.png"></p>
<p>让我们从一个任务开始吧。根据 div 元素 data-idx 属性的值展示对应的文案。data-idx 的值从 -1 开始，由于我们使用了数组存放数据，所以我们在使用 data-idx 时给它加 1 ，示例如下：</p>
<p>HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span> <span class="attr">data-idx</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Copywriter = [</span><br><span class="line">    <span class="string">"joybuy.com"</span>,</span><br><span class="line">    <span class="string">"jd.ru"</span>,</span><br><span class="line">    <span class="string">"jd.th"</span>,</span><br><span class="line">    <span class="string">"jd.id"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> $dom = <span class="built_in">document</span>.querySelector(<span class="string">"#demo"</span>)</span><br><span class="line"><span class="keyword">const</span> idx = $dom.getAttribute(<span class="string">"data-idx"</span>)</span><br><span class="line"></span><br><span class="line">$dom.innerHTML = Copywriter[idx + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><code>div#demo</code> 元素中的文案是什么呢？没错，<code>undefined</code>！</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span> <span class="attr">data-idx</span>=<span class="string">"1"</span>&gt;</span>undefined<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>getAttribute()</code> 方法返回的是 string 类型的值，在JavaScript中只能用整数作为数组元素的索引，而不能用字符串。<code>Copywriter[idx + 1]</code> 的本意是返回数组中下标为 <code>x + 1</code> 的元素。在本例中我们期望<code>x + 1 = 2</code>但是它实际的结果是字符串<code>11</code>。在代码运行时会将字符串<code>11</code>转换为整数并作为索引值使用，所以我们执行后的结果便是<code>undefined</code>。</p>
<p>上面的代码示例之所以产生问题，是因为没有认识到 <code>getAttribute()</code> 方法返回的是 string。为了让代码正确运行，需要对 idx 进行类型转换。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$dom.innerHTML = Copywriter[<span class="built_in">Number</span>(idx) + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>从上面示例我们可以发现 Bug 是在程序运行阶段暴露的，这是因为 Javascript 是动态多类型语言，类型检查发生在程序运行期间。<br>TypeScript 的静态类型检查允许我们在程序运行之前就可以确定我们所设定的确定性是否是对的。我们可以将上述代码保存到 <code>.ts</code> 的文件中，然后观察一下：</p>
<p><img src="https://s1.ax1x.com/2020/06/04/tBhOsJ.png" alt="tBhOsJ.png"></p>
<p>通过上面的示例可以看到 TypeScript 静态类型检查带给我们的好处（使用静态类型检查的好处可以查看：<a href="https://www.freecodecamp.org/news/why-use-static-types-in-javascript-part-1-8382da1e0adb/" target="_blank" rel="noopener">Why use static types in JavaScript</a>），<br>有了 TypeScript 的静态类型，我们就需要从 JavaScript 动态类型的思维模式转换到 TypeScript 静态类型的思维模式。</p>
<p><img src="https://s1.ax1x.com/2020/06/01/tJXrpF.png" alt="tJXrpF.png"></p>
<p>在《C语言非常道》一书中，作者在前言部分写到：”学习 C 语言的诀窍在哪里呢？首先，掌握它的类型系统并学会以类型的观点来构造和解析程序中的代码，这样你就不会迷路。如果你没有掌握 C 语言的类型系统，不会从类型的角度来分析一个表达式，说明你并没有掌握 C 语言”。<br>对于 TypeScript 来说，需要掌握 TypeScript 所支持的类型系统，并以类型的观点来编写 Typescript 程序（由于 Typescript 是 JavaScript 的超集，你当然也可以不用静态类型的观念来编写程序）。</p>
<p>TypeScript 中提供了泛型，这是一个和类型密切相关的概念，接下里我们将从一个 JavaScript 编写的 find 函数开始，然后通过实例的方式说明泛型的概念。</p>
<p>函数 <code>find()</code> ：从每个元素均为 number 类型的数组中查找一个值，并返回一个包含该值的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">source, expect</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> filtered = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> idx = <span class="number">0</span>; idx &lt; source.length; idx++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(source[idx] == expect) &#123;</span><br><span class="line">            filtered.push(source[idx])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的实现中，我们将判定条件固定为 <code>==</code>，考虑到查找的可能会有多种（小于、大于..），我们需要重构此方法，让它可以支持多种匹配条件。一个解决办法是将判定条件替换为 function，此 function 始终返回 boolean 类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">source, expect, filter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> filtered = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> idx = <span class="number">0</span>; idx &lt; source.length; idx++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(filter(source[idx], expect)) &#123;</span><br><span class="line">            filtered.push(source[idx])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的 find 函数适用范围比之前大了一些。除了适应各项元素均为 number 的数组，也同样适用于各项元素均为 string 的数组。<br>接下来的任务是将上面的 find 函数使用 TypeScript 改写。那我们要做的事情是给参数、返回值、函数体内的变量增加类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function find(source:number[], expect:number, filter:(a:number, b:number)=&gt;boolean):number[] &#123;</span><br><span class="line">    <span class="keyword">let</span> filtered:number[] = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> idx:number = <span class="number">0</span>; idx &lt; source.length; idx++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(filter(source[idx], expect)) &#123;</span><br><span class="line">            filtered.push(source[idx])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filtered</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function find_string(source:string[], expect:string, filter:(a:string, b:string)=&gt;boolean):string[] &#123;</span><br><span class="line">    <span class="keyword">let</span> filtered:string[] = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> idx:number = <span class="number">0</span>; idx &lt; source.length; idx++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(source[idx].indexOf(expect) != <span class="number">-1</span>) &#123;</span><br><span class="line">            filtered.push(source[idx])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让 find 支持 number 类型的数组和 string 类型的数组，我们实现了两个函数。然而，<br>在最开始的实现中我们只提供了一个 find 函数，可是上面的实现中确有两个不同名称的实现了 find 功能的函数。假如要增加对各项元素均为 boolean 数组的支持，那我们还需要实现一个名为 find_boolean 的函数。我们并不想给每种类型实现一个 find 函数，我们要像刚开始那样，只提供名为 find 的函数，所以这里我们通过函数重载来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在定义重载的时候，一定要把最精确的定义放在最前面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载列表</span></span><br><span class="line">function find(source:string[], expect:string, filter:(a:string, b:string)=&gt;boolean):string[];</span><br><span class="line">function find(source:number[], expect:number, filter:(a:number, b:number)=&gt;boolean):number[];</span><br><span class="line"><span class="comment">// 不是重载列表的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">source:any, expect:any, filter:any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> expect === <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> filtered:number[] = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> idx:number = <span class="number">0</span>; idx &lt; source.length; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(filter(source[idx], expect)) &#123;</span><br><span class="line">                filtered.push(source[idx])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filtered</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> expect === <span class="string">"string"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> filtered:string[] = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> idx:number = <span class="number">0</span>; idx &lt; source.length; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(filter(source[idx], expect)) &#123;</span><br><span class="line">                filtered.push(source[idx])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filtered</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的实现中，我们使用 typeof 运算符将 expect 参数的类型收窄，并针对每种类型编写了实现逻辑。但是实现逻辑大同小异，目前看来仅仅是类型不一致。对此我们有如下想法：</p>
<ul>
<li>消除手工编写的类型收窄代码</li>
<li>可以在调用函数时指定函数所支持的类型</li>
<li>不消减静态类型检查带来的收益</li>
</ul>
<p>上面的想法可以使用泛型来实现。于是我们可以通过泛型改写此方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function find&lt;T&gt;(source:T[], expect:T, filter:(a:T, b:T)=&gt;boolean): T[] &#123;</span><br><span class="line">    <span class="keyword">let</span> filtered:T[] = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> idx:number = <span class="number">0</span>; idx &lt; source.length; idx++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(filter(source[idx], expect)) &#123;</span><br><span class="line">            filtered.push(source[idx])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以这样调用 find 函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find&lt;number&gt;<span class="function">(<span class="params">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="number">2</span>, (a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a == b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在上面的实现中参数 source 是一个数组，其各项类型均为 T，T 可以在函数调用时指定具体类型名称。这意味着我们可以处理包含任意类型的数组。对于数组 source 我们使用 for 循环来处理。假如 source 是一个对象字面量，其值是 <code>{a: 1, b: 2, c: 3}</code> 或者 <code>{d: 4, e: 5, f:6}</code> 等等，我们应该怎样处理呢？我们可以使用 <code>for...in</code> 对其进行遍历。假如 source 是一个单向链表、可枚举对象，甚至是任意对象，我们该怎样处理呢？拿单向链表来说，通常我们使用 <code>while</code> 循环遍历数据并处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(currentNode) &#123;</span><br><span class="line">    <span class="keyword">if</span>(currentNode.value == expect) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在任意的数组、对象、单向链表中查找数据总是要依赖遍历，而且它们有各自的循环遍历方式，我们要在函数的具体实现中编写各种类型校验，用以指定循环处理方法。我们是不是可以将数据的循环遍历进行抽象，用统一的方式来表达循环遍历呢？我们可以借助<code>迭代器</code>。迭代器允许我们遍历对象，但无须关注对象内部数据的组织方式，也就是说无论数据是线性的还是离散的我们都可以遍历。</p>
<p><img src="https://s1.ax1x.com/2020/06/01/tJHMn0.png" alt="tJHMn0.png"></p>
<p>通过使用迭代器我们还可以将数据结构和算法分离，比如 C++ 的 STL（标准模版库） 所提供的组件其元素可以是任意类型，并借助迭代器将数据结构和算法分离，从而获得具有通用性的程序组件。对于 find 函数而言，数据结构是指 source 具体的值类型，算法即 filter 函数内部的数据处理逻辑。</p>
<p><img src="https://s1.ax1x.com/2020/06/01/tJbUPg.png" alt="tJbUPg.png"></p>
<p>在 JavaScript 中可以通过 <code>Symbol.iterator</code> 为每个对象定义默认的迭代器，使其成为可迭代对象，配合 <code>for...of</code> 实现数据与算法的分离。<code>for...of</code> 语句可在迭代对象上创建一个迭代循环，调用自定义的<code>Symbol.iterator</code>。</p>
<p><img src="https://s1.ax1x.com/2020/06/05/tsmBTO.png" alt="tsmBTO.png"></p>
<p>例如，我们使用 <code>Symbol.iterator</code> 给 LinkedList 定义一个迭代器，使其成为可迭代对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    data:T</span><br><span class="line">    next:LinkedListNode&lt;T&gt;|<span class="literal">null</span></span><br><span class="line">    <span class="keyword">constructor</span>(data:T) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    head:LinkedListNode&lt;T&gt;|<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(data:T) &#123;</span><br><span class="line">        <span class="keyword">const</span> newNode:LinkedListNode&lt;T&gt; = <span class="keyword">new</span> LinkedListNode&lt;T&gt;(data);</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">while</span> (current.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = newNode;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *values()&#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> current.data;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.values();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> LinkedList&lt;number&gt;()</span><br><span class="line">list.add(<span class="number">0</span>)</span><br><span class="line">list.add(<span class="number">1</span>)</span><br><span class="line">list.add(<span class="number">2</span>)</span><br><span class="line">list.add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> list) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了 <code>function*</code> 生成器函数，它返回一个 <code>Generator</code> 对象，并且 <code>Generator</code> 对象符合<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterable" target="_blank" rel="noopener">可迭代协议</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator" target="_blank" rel="noopener">迭代器协议</a>。也就是说 <code>[Symbol.iterator]()</code> 返回一个可迭代对象。</p>
<p>在了解了迭代器、迭代器作用、迭代器实现后，我们需要修改 find 方法，使它能配合迭代器处理数据，并让其可支持更多类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface Iterable&lt;T&gt; &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator](): IterableIterator&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line">function find&lt;T extends Iterable&lt;E&gt;, E&gt;(source:T, expect:E, filter:(a:E, b:E)=&gt;boolean): E[] &#123;</span><br><span class="line">    <span class="keyword">let</span> filtered:E[] = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span>(filter(item, expect)) &#123;</span><br><span class="line">            filtered.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">a:number, b:number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt;= b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find&lt;LinkedList&lt;number&gt;,number&gt;(list, <span class="number">1</span>, filter)</span><br></pre></td></tr></table></figure>



<p>TypeScript 的类型系统是<a href="https://zhuanlan.zhihu.com/p/64446259" target="_blank" rel="noopener">结构化类型系统</a>，<code>interface</code> 主要是用来描述类型的形状，也就是说类型所具有的特征。我们使用 <code>interface</code> 对泛型 T 做出约束，要求其必须具备 <code>Iterable</code> 所具有的特性，也就是说 find 函数适用于所有带有迭代器的数据。对于用户指定的特殊数据类型，只要这个类型实现了迭代器，find 函数就可以处理。这样我们可以创造出更多的泛型函数，甚至构造自己的泛型函数库。那我们是如何推导出泛型 T 的约束条件呢？我们来看下面的 JavaScript 示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">source, expect, filter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> filtered = []</span><br><span class="line">    <span class="comment">// T extends Iterable&lt;E&gt;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> source[<span class="built_in">Symbol</span>.iterator] != <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"source must be an iterable"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// filter:(a:E, b:E)=&gt;boolean</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> filter != <span class="string">"function"</span> || (<span class="keyword">typeof</span> filter === <span class="string">"function"</span> &amp;&amp; filter.length != <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"filter must be a function with a Boolean return value"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> source) &#123;</span><br><span class="line">        <span class="comment">// E</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> item === <span class="keyword">typeof</span> expect) &#123;</span><br><span class="line">            <span class="keyword">if</span>(filter(item, expect)) &#123;</span><br><span class="line">                filtered.push(item)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对泛型 T 的约束实际就是对泛型 T 提出要求，换一种说法就是我们判断类型是否满足某些条件，进而将这些条件转换为对泛型 T 的要求。在上面的代码中，我们使用 <code>if(typeof source[Symbol.iterator] != &quot;function&quot;)</code> 来判定 source 参数是否满足迭代器的要求。</p>
<p>source 参数的迭代器返回类型为 E 的值，对于泛型 E 我们要求它必须能够比较两个值，包括相等(==)、大于(&gt;)、小于(&lt;)、小于等于(&lt;=)、大于等于(&gt;=)等操作，并要求其比较操作总是返回 boolean 值。</p>
<p>在 find 函数中我们使用 filter 函数作为参数，通过使用 filter 函数，我们可以给不的数据结构提供相同的相等(==)、大于(&gt;)、小于(&lt;)、小于等于(&lt;=)、大于等于(&gt;=)等操作。</p>
<p>比如在单向链表中的元素不是数字类型而是 Object 类型，那我们就要给 Object 实现相等(==)、大于(&gt;)、小于(&lt;)、小于等于(&lt;=)、大于等于(&gt;=)等操作。我们可以通过函数的方式实现上述操作，也可将其挂到 Object 原型上。这里举例说明相等(==)运算，在实现相等元算前要先讲明两个对象满足什么条件才可叫做相等，这里我们约定对象 a.key==b.key ，且 key的个数相等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a:any, b:any</span>):<span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(a) === <span class="built_in">Object</span>.keys(b)) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a[key] != b[key]) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Demo &#123;</span><br><span class="line">    [key:string]:any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> LinkedList&lt;Demo&gt;()</span><br><span class="line">list.add(&#123;<span class="string">"a"</span>:<span class="number">1</span>&#125;)</span><br><span class="line">list.add(&#123;<span class="string">"b"</span>:<span class="number">2</span>&#125;)</span><br><span class="line">list.add(&#123;<span class="string">"c"</span>:<span class="number">3</span>&#125;)</span><br><span class="line">list.add(&#123;<span class="string">"d"</span>:<span class="number">4</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">a:number, b:number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> eq(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find&lt;LinkedList&lt;Demo&gt;,Demo&gt;(list, &#123;<span class="string">"a"</span>:<span class="number">1</span>&#125;, filter)</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>泛型是对类型进行抽象，在调用泛型函数的时候将参数类型实例化。对类型进行抽象，实际上是指对类型提出一系列要求，比如类型支持的操作、这些操作的语义等。借助于泛型和迭代器我们可以拓广算法支持的范围。</p>
<p>有些函数重载可以使用泛型替换，比如上文中参数数量不变但是值类型不一致的函数重载可以替换为泛型。<br>我们可以在函数重载的基础上进行泛型推导，借此归纳类型应该满足的要求，并逐步将各个关注点分离。</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/04/09/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E5%9C%A8%E5%89%8D%E7%AB%AF%E5%8A%A8%E6%95%88%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0/">计算思维在前端动效开发中的体现</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-04-09T09:34:17.012Z" itemprop="datePublished">
    2020-04-09
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4/">计算思维</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>我们要做一个数字滚动增长的动效，从 0 - 3000 的变化持续 3秒。我们可以将此问题转化为平均速度求值的问题，例如：一辆汽车从 A 地开往 B 地，A 和 B之间的距离为 3000 米，这辆汽车从 A 地到 B 地耗时 3个小时。让我们求一下这辆车的平均速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">平均速度 &#x3D; (B - A) &#x2F; 3</span><br><span class="line">平均速度 &#x3D; (3000) &#x2F; 3</span><br><span class="line">平均速度 &#x3D; 1000  每小时1000米</span><br></pre></td></tr></table></figure>
<p>让我们把问题在转回到数字增长的动效，我们完全可以参考求汽车平均速度的模型来计算数字增长动效的增长过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">平均增长 &#x3D; （3000 - 0）&#x2F; 3</span><br><span class="line">平均增长 &#x3D; 1000</span><br></pre></td></tr></table></figure>
<p>这样我们得出每秒需要增加的数值，我们假定动画以每秒 60 帧播放，则还需计算每帧的平均增长。</p>
<pre><code>每帧平均增长 = 1000 / 60
每帧平均增长 = 16.666666666666668</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tick = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> endNum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcNum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tick &gt; <span class="number">3</span> * <span class="number">60</span>) <span class="keyword">return</span> cancelAnimationFrame(requestAnimationFrameID)</span><br><span class="line">  endNum = <span class="number">16.666666666666668</span> * tick</span><br><span class="line">  $demo.innerHTML = endNum.toFixed(<span class="number">0</span>)</span><br><span class="line">  tick += <span class="number">1</span></span><br><span class="line">  requestAnimationFrame(calcNum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> requestAnimationFrameID = <span class="built_in">window</span>.requestAnimationFrame(calcNum)</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/wanbei08/pen/pojojNm?editors=0110" target="_blank" rel="noopener">https://codepen.io/wanbei08/pen/pojojNm?editors=0110</a></p>
<p>好了，接下来该测试了。🤩，数字增长的好快，闪瞎双眼。看来要改进一下这个模型了。</p>
<p>让我们再次回到汽车平均速度的问题上。汽车从 A 到 B，耗时 3 小时，A 和 B 距离 3000 米。那怎么计算汽车行驶 0.5 小时后所在的位置呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; fn(t)</span><br></pre></td></tr></table></figure>
<p>汽车位置是一个关于时间的函数，时间改变，位置发生相应的改变。我们在上面的实现中使用了时间和速度来求得位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; fn(t, v)</span><br><span class="line"></span><br><span class="line">v：平均速度</span><br></pre></td></tr></table></figure>
<p>好了，让我们来看看 v 是怎么计算出来的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(B - A) &#x2F; d</span><br><span class="line"></span><br><span class="line">B - A &#x3D; c</span><br><span class="line"></span><br><span class="line">c: 物体移动的距离</span><br><span class="line">d: 持续时间，这里汽车持续行驶 3 个小时</span><br><span class="line">所以：</span><br><span class="line">v &#x3D; c &#x2F; d</span><br></pre></td></tr></table></figure>

<p>让我们来改一下上面求 p 的公式吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = fn(t, c)</span><br></pre></td></tr></table></figure>
<p>p 已经变成了关于 t 和 c 的函数，也就是说，我可以求得任意A、B之间的某一时刻的汽车位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="function"><span class="keyword">function</span>(<span class="params">c, d, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t * c/d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理想的状态下汽车以平均速度行驶，但是在现实生活中，很难做到一直一个速度开车，在路途中可能一会快一会慢，但是到达目的地所花费的时间是不变的。这也就是说，我们的速度是一直在变化的。那我们应该怎么模拟这种变速的状态呢？</p>
<p>先让我们看一附图：</p>
<p><img src="https://img14.360buyimg.com/imagetools/jfs/t1/109940/23/11667/24402/5e8d933dEa5024b7f/24e7d56736ce166e.png" alt=""></p>
<p>从上图可以看出，平均速度不变，只是时间的一个变化。所以我们只需要给时间一点魔法，便可以让汽车的行进更加神奇。此时的函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">magic = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> magicT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = <span class="function"><span class="keyword">function</span>(<span class="params">c, d, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c * magic(t/d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：我们所使用的魔法只能是 0 到 1 的闭区间函数。</p>
<p>那我们回到数字增长的效果上来吧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">magic</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.pow(t<span class="number">-1</span>, <span class="number">3</span>) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span>(<span class="params">t, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c * magic(t/d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3000</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="number">180</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcNum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; d) &#123;</span><br><span class="line">        <span class="keyword">return</span> cancelAnimationFrame(requestAnimationFrameID)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cp = p(t, c, d)</span><br><span class="line">    $demo.innerHTML = cp.toFixed(<span class="number">0</span>)</span><br><span class="line">    t += <span class="number">1</span></span><br><span class="line">    requestAnimationFrame(calcNum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> requestAnimationFrameID = <span class="built_in">window</span>.requestAnimationFrame(calcNum)</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/wanbei08/pen/PoPoPjB?editors=0010" target="_blank" rel="noopener">https://codepen.io/wanbei08/pen/PoPoPjB?editors=0010</a></p>
<p>好吧，使用神奇的魔法，数字变化还是非常快。尤其是个位数。</p>
<p>看来仅仅使用一种魔法是控制不住这个恶魔 👿的。在想想还能不能在魔法的基础上增加一种魔法呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="function"><span class="keyword">function</span>(<span class="params">c, d, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t * c/d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们盯着这个公式看一会，再看一会。我们回想一下汽车的运动，汽车是持续不断地移动，那我们能不能施加一些魔法，让它拥有瞬移的本领呢？为了让汽车可以瞬移，我们唯一需要控制的就是汽车所处的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = fn(t)</span><br></pre></td></tr></table></figure>
<p>我们让 p 也变成一个关于 t （时间）的函数，通过通过时间来计算 p 是不是需要更新。</p>
<p>那让我们来试试吧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">magic</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.pow(t<span class="number">-1</span>, <span class="number">3</span>) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span>(<span class="params">t, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c * magic(t/d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3000</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="number">180</span></span><br><span class="line"><span class="keyword">let</span> skip = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcNum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; d) &#123;</span><br><span class="line">        <span class="keyword">return</span> cancelAnimationFrame(requestAnimationFrameID)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cp = p(t, c, d)</span><br><span class="line">    <span class="comment">// 每隔 n-1 播放一次</span></span><br><span class="line">    <span class="keyword">if</span>(skip == <span class="number">4</span>) skip = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(skip == <span class="number">0</span>) $demo.innerHTML = cp.toFixed(<span class="number">0</span>)</span><br><span class="line">    t += <span class="number">1</span></span><br><span class="line">    skip += <span class="number">1</span></span><br><span class="line">    requestAnimationFrame(calcNum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> requestAnimationFrameID = <span class="built_in">window</span>.requestAnimationFrame(calcNum)</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/wanbei08/pen/LYpYpjy?editors=0010" target="_blank" rel="noopener">https://codepen.io/wanbei08/pen/LYpYpjy?editors=0010</a></p>
<p>在这里我们通过设置暂停帧，来降低数字增长频率，这种方法设置简单（上面的方法并没有考虑边界情况）。</p>
<p>这样我们可以给数字增长减速了，同时还保证了持续时间。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>来总结一下我们是怎样一步一步的让数字动起来的吧。</p>
<ul>
<li>把实际问题抽象为数学问题，并建模。这里我们把数字增长动效进行了抽象，将其抽象为一个关于时间的函数。</li>
<li>进行映射，把数学模型中的变量等用特定符号代替。用符号一一对应数学模型中的变量和规则等。这里的符号可以理解为程序中的函数。</li>
<li>通过编程把解决问题的逻辑分析过程写成算法，把解题思路转换为计算机指令。也就是说我们将函数之间的逻辑关系，以及函数内部的具体处理逻辑写出来。</li>
<li>计算机根据指令自动执行，求出结果。</li>
</ul>
<p>建立数学模型的过程就是理解问题的过程，并且要把我们对问题的理解用数学语言描述出来，这很关键。在整个过程中，抽象是方法和手段，贯穿整个过程的每个环节。</p>

      
    </div>
</article>

    </li>
  
</ul>


            <footer>
    <div>© 2021 - Tigger </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm" target="_blank" rel="noopener">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>